{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to pyepidemics documentation \u00b6 Open-source epidemics modeling Python library pyepidemics is a Python library to easily manipulate epidemiological models (SIR, SEIR, COVID19), forecast, and test policy scenarios. Main features are: Creation of classical compartmental models (SIR, SEIR, SEIDR, etc...) Creation of COVID19 related model (with ICU and different levels of symptoms) Creation of custom compartmental model Easy extend to compartmental model on different levels (by age, by region, by age and region, etc...) Implementation of contact matrices Implementation of policies (lockdown, tracing, testing, etc...) Calibration of epidemiological parameters on real-world data using Bayesian optimization Data helpers to get up-to-date data (cases, beds availability, population contact matrices) (NB as of today only for France cases) Simple curve fitting algorithms Economics modeling on consumption and production Warning This library is under active development, please contact Th\u00e9o Alves Da Costa if you need more information and would like to contribute Contributors \u00b6 The library has been initially developed by Ekimetrics under the coalition of French AI companies CoData or help French government response to the COVID19 pandemics. Main contributors are: Th\u00e9o Alves Da Costa , Ekimetrics L\u00e9o Grosjean, Ekimetrics Pierre Carles, Ekimetrics Nicolas Chesneau, Ekimetrics Marianne Chehade, Ekimetrics Jean-Baptiste Remy","title":"Welcome to pyepidemics documentation"},{"location":"#welcome-to-pyepidemics-documentation","text":"Open-source epidemics modeling Python library pyepidemics is a Python library to easily manipulate epidemiological models (SIR, SEIR, COVID19), forecast, and test policy scenarios. Main features are: Creation of classical compartmental models (SIR, SEIR, SEIDR, etc...) Creation of COVID19 related model (with ICU and different levels of symptoms) Creation of custom compartmental model Easy extend to compartmental model on different levels (by age, by region, by age and region, etc...) Implementation of contact matrices Implementation of policies (lockdown, tracing, testing, etc...) Calibration of epidemiological parameters on real-world data using Bayesian optimization Data helpers to get up-to-date data (cases, beds availability, population contact matrices) (NB as of today only for France cases) Simple curve fitting algorithms Economics modeling on consumption and production Warning This library is under active development, please contact Th\u00e9o Alves Da Costa if you need more information and would like to contribute","title":"Welcome to pyepidemics documentation"},{"location":"#contributors","text":"The library has been initially developed by Ekimetrics under the coalition of French AI companies CoData or help French government response to the COVID19 pandemics. Main contributors are: Th\u00e9o Alves Da Costa , Ekimetrics L\u00e9o Grosjean, Ekimetrics Pierre Carles, Ekimetrics Nicolas Chesneau, Ekimetrics Marianne Chehade, Ekimetrics Jean-Baptiste Remy","title":"Contributors"},{"location":"quickstart/","text":"Quickstart \u00b6 Creating a SIR model \u00b6 # Import library from pyepidemics.models import SIR # Let's take approximate parameters during COVID19 epidemics N = 67e6 beta = 3.3 / 4 gamma = 1 / 4 # Instantiate model with epidemiological parameters sir = SIR ( N , beta , gamma ) # Solve for one infected case for 100 days starting from 2020-01-24 states = sir . solve ( 1 , n_days = 100 , start_date = \"2020-01-24\" ) # Visualize epidemic curves using matplotlib (plotly available) states . show ( plotly = False ) Creating a custom compartmental model \u00b6 Here is the example to create a model like the SIR described above from pyepidemics.models import CompartmentalModel class SIR ( CompartmentalModel ): def __init__ ( self , N , beta , gamma ): # Define compartments name and number compartments = [ \"S\" , \"I\" , \"R\" ] super () . __init__ ( compartments ) # Parameters self . N = N # Total population self . beta = beta # How many person each person infects per day self . gamma = gamma # Rate of infection, duration = 1/gamma # Add transition self . add_transition ( \"S\" , \"I\" , lambda y , t : self . beta * y [ \"S\" ] * y [ \"I\" ] / self . N ) self . add_transition ( \"I\" , \"R\" , lambda y , t : self . gamma * y [ \"I\" ])","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#creating-a-sir-model","text":"# Import library from pyepidemics.models import SIR # Let's take approximate parameters during COVID19 epidemics N = 67e6 beta = 3.3 / 4 gamma = 1 / 4 # Instantiate model with epidemiological parameters sir = SIR ( N , beta , gamma ) # Solve for one infected case for 100 days starting from 2020-01-24 states = sir . solve ( 1 , n_days = 100 , start_date = \"2020-01-24\" ) # Visualize epidemic curves using matplotlib (plotly available) states . show ( plotly = False )","title":"Creating a SIR model"},{"location":"quickstart/#creating-a-custom-compartmental-model","text":"Here is the example to create a model like the SIR described above from pyepidemics.models import CompartmentalModel class SIR ( CompartmentalModel ): def __init__ ( self , N , beta , gamma ): # Define compartments name and number compartments = [ \"S\" , \"I\" , \"R\" ] super () . __init__ ( compartments ) # Parameters self . N = N # Total population self . beta = beta # How many person each person infects per day self . gamma = gamma # Rate of infection, duration = 1/gamma # Add transition self . add_transition ( \"S\" , \"I\" , lambda y , t : self . beta * y [ \"S\" ] * y [ \"I\" ] / self . N ) self . add_transition ( \"I\" , \"R\" , lambda y , t : self . gamma * y [ \"I\" ])","title":"Creating a custom compartmental model"},{"location":"references/","text":"References \u00b6 \u270c For beginners \u00b6 Infectious Disease Modelling: Beyond the Basic SIR Model \ud83d\udcda Research papers \u00b6 For France \u00b6 Expected impact of lockdown in \u00cele-de-France and possible exit strategies - by INSERM Estimating the burden of SARS-CoV-2 in France - by Institut Pasteur \u00c9pid\u00e9mie de COVID-19 \u2013 Point sur la mod\u00e9lisation \u00e9pid\u00e9miologique pour estimer l\u2019ampleur et le devenir de l\u2019\u00e9pid\u00e9mie de COVID-19 \ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc66 Agent-Based modeling \u00b6 Mobility traces and the spreading of COVID-19 with Github and research paper Reproducible scenarios for agent-based transport simulation A case study for Paris and \u00cele-de-France","title":"References"},{"location":"references/#references","text":"","title":"References"},{"location":"references/#for-beginners","text":"Infectious Disease Modelling: Beyond the Basic SIR Model","title":"\u270c For beginners"},{"location":"references/#research-papers","text":"","title":"\ud83d\udcda Research papers"},{"location":"references/#for-france","text":"Expected impact of lockdown in \u00cele-de-France and possible exit strategies - by INSERM Estimating the burden of SARS-CoV-2 in France - by Institut Pasteur \u00c9pid\u00e9mie de COVID-19 \u2013 Point sur la mod\u00e9lisation \u00e9pid\u00e9miologique pour estimer l\u2019ampleur et le devenir de l\u2019\u00e9pid\u00e9mie de COVID-19","title":"For France"},{"location":"references/#agent-based-modeling","text":"Mobility traces and the spreading of COVID-19 with Github and research paper Reproducible scenarios for agent-based transport simulation A case study for Paris and \u00cele-de-France","title":"\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc66 Agent-Based modeling"},{"location":"documentation/curve_fitting/","text":"Curve Fitting \u00b6 ::: pyepidemics.curve_fitting rendering: show_source: true","title":"Curve Fitting"},{"location":"documentation/curve_fitting/#curve-fitting","text":"::: pyepidemics.curve_fitting rendering: show_source: true","title":"Curve Fitting"},{"location":"documentation/datasets/","text":"Dataset \u00b6","title":"Dataset"},{"location":"documentation/datasets/#dataset","text":"","title":"Dataset"},{"location":"documentation/model/","text":"Compartmental Models bases classes \u00b6 ::: pyepidemics.models.model rendering: show_source: true","title":"Compartmental Models bases classes"},{"location":"documentation/model/#compartmental-models-bases-classes","text":"::: pyepidemics.models.model rendering: show_source: true","title":"Compartmental Models bases classes"},{"location":"documentation/models_classical/","text":"Classical compartmental models \u00b6 ::: pyepidemics.models.examples.sir rendering: show_source: true ::: pyepidemics.models.examples.seir rendering: show_source: true ::: pyepidemics.models.examples.seidr rendering: show_source: true ::: pyepidemics.models.examples.seihdr rendering: show_source: true","title":"Classical compartmental models"},{"location":"documentation/models_classical/#classical-compartmental-models","text":"::: pyepidemics.models.examples.sir rendering: show_source: true ::: pyepidemics.models.examples.seir rendering: show_source: true ::: pyepidemics.models.examples.seidr rendering: show_source: true ::: pyepidemics.models.examples.seihdr rendering: show_source: true","title":"Classical compartmental models"},{"location":"documentation/models_covid/","text":"COVID19 Compartmental models \u00b6 ::: pyepidemics.models.examples.covid_prodromal rendering: show_source: true","title":"COVID19 Compartmental models"},{"location":"documentation/models_covid/#covid19-compartmental-models","text":"::: pyepidemics.models.examples.covid_prodromal rendering: show_source: true","title":"COVID19 Compartmental models"},{"location":"documentation/params_optimizer/","text":"Epidemiology parameters calibration optimizer \u00b6 ::: pyepidemics.params.optimizer rendering: show_source: true","title":"Epidemiology parameters calibration optimizer"},{"location":"documentation/params_optimizer/#epidemiology-parameters-calibration-optimizer","text":"::: pyepidemics.params.optimizer rendering: show_source: true","title":"Epidemiology parameters calibration optimizer"},{"location":"tutorials/curve_fitting/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Curve fitting tutorial \u00b6 Note Curve fitting is the simple process of finding a surrogate function approximating a system dynamics, ie curve fitting. For example in epidemiology, cumulative deaths grow slowly at first, accelerate when the epidemics is at the peak and slows down to reach a plateau, this can be approximated using a logistic function. # Base Data Science snippet import pandas as pd import numpy as np import matplotlib.pyplot as plt import os import time from tqdm import tqdm_notebook % matplotlib inline % load_ext autoreload % autoreload 2 # Developer import import sys sys . path . append ( \"../\" ) The autoreload extension is already loaded. To reload it, use: %reload_ext autoreload import pyepidemics Introduction \u00b6 Introduction to curve fitting \u00b6 Epidemic curves often follow a particular shape : Cumulative deaths reach a plateau, we could approximate it with a logistic curve Infections, stay in hospital, often reach a peak before declining, we could approximate it with a gaussian or skewed gaussian curve This is what curve fitting is about, once we have a surrogate function approximating the epidemic curve we can make predictions. Yet it only works under the assumption that the situation is constant which is totally unrealistic. However even if the model is wrong, that does not mean is not useful, curve fitting can easily be used at scale on many countries or used to capture the dynamics of epidemics curve to better calibrate compartmental models Getting some data \u00b6 from pyepidemics.dataset import fetch_daily_case_france cases = fetch_daily_case_france () cases [[ \"D\" , \"H\" , \"ICU\" ]] . plot ( figsize = ( 15 , 4 ), title = \"COVID19 cases (D=Dead,H=Hospital,ICU)\" ) plt . show () Curve fitting in practice \u00b6 from pyepidemics.curve_fitting import logistic_fn , gaussian_fn from pyepidemics.curve_fitting import CurveFittingModel Surrogate functions \u00b6 Logistic function \u00b6 A logistic function is useful to represent system dynamics reaching a plateau after an inflexion. More on the wikipedia page https://en.wikipedia.org/wiki/Logistic_function Formula is : f(x)=\\frac{a}{1+e^{-k(x - \\mu)}} f(x)=\\frac{a}{1+e^{-k(x - \\mu)}} We can use the fonction pyepidemics.curve_fitting.logistic_fn(x,a,mu,k) # Take x between 0 and 100 x = np . linspace ( 0 , 100 ) # Prepare plot plt . figure ( figsize = ( 15 , 4 )) # Plot many functions for k in [ 0.05 , 0.1 , 0.2 , 0.5 , 1 ]: plt . plot ( logistic_fn ( x , k = k , a = 10 , mu = 50 ), label = f \"k={k}\" ) # Display figure plt . title ( \"Logistic functions\" ) plt . legend () plt . show () Gaussian function \u00b6 Formula is : f(x)=a e^{-0.5(\\frac{x-\\mu}{\\sigma})^2} f(x)=a e^{-0.5(\\frac{x-\\mu}{\\sigma})^2} We can use the fonction pyepidemics.curve_fitting.gaussian_fn(x,a,mu,sigma) # Take x between 0 and 100 x = np . linspace ( 0 , 100 ) # Prepare plot plt . figure ( figsize = ( 15 , 4 )) # Plot many functions for sigma in [ 5 , 10 , 20 ]: plt . plot ( gaussian_fn ( x , sigma = sigma , a = 10 , mu = 50 ), label = f \"sigma={sigma}\" ) # Display figure plt . title ( \"Gaussian functions\" ) plt . legend () plt . show () Fitting surrogate functions to COVID cases \u00b6 We will use the CurveFittingModel which merely wraps curve_fit function from scipy in a scikit learn fashion. from pyepidemics.curve_fitting import CurveFittingModel Fitting the death cases \u00b6 Let's start by fitting the death cases with a logistic function model = CurveFittingModel ( \"logistic\" ) Fitting returns the parameters a,mu,k of the logistics function model . fit ( cases [ \"D\" ]) array([1.75350267e+04, 7.87308460e+01, 1.16910544e-01]) Let's predict for 20 days after the date and visualize the fit pred = model . predict ( 20 , show_fit = True ) Fitting the ICU cases with gaussian curve \u00b6 model = CurveFittingModel ( \"gaussian\" ) pred = model . fit_predict ( cases [ \"ICU\" ], show_fit = True ) It works ok, but actually ICU cases are not a proper gaussian curve, we have a step ascend in the number of cases, and a slower decline. Hence what we need here could simply be a skewed guassian model = CurveFittingModel ( \"skewed_gaussian\" ) pred = model . fit_predict ( cases [ \"ICU\" ], show_fit = True ) Now we have a much better fit Advanced users \u00b6 There are a few details you can use as an advanced user, deep dive into the code internals to learn more : You can specify the initial parameters p0 of the curve fitting optimization freely by passing p0 argument to the fit or fit_predict function. Actually for the gaussian functions those initial parameters are automatically inferred from the dataset provided to facilitate convergence. You can actually specify any function to fit in the curve fitting model as shown below Fitting a custom function \u00b6 Let's create a fake dataset with a simple linear function # Preparing the true function and the function with noise example_fn = lambda x , a , b : a * x + b example_fn_random = lambda x , a , b : example_fn ( x , a , b ) + np . random . randn ( len ( x )) * 2 # Parameter we want to estimate a = 2 b = 1 # Creating fake dataset x = np . linspace ( 0 , 20 ) y = example_fn_random ( x , a , b ) # Visualizing fake dataset plt . figure ( figsize = ( 15 , 4 )) plt . scatter ( x , y ) plt . show () And here we are, we have a Linear Regression model model = CurveFittingModel ( example_fn ) pred = model . fit_predict ( y ) # Visualizing fake dataset plt . figure ( figsize = ( 15 , 4 )) plt . scatter ( x , y ) plt . plot ( x , pred ) plt . show ()","title":"Curve fitting"},{"location":"tutorials/curve_fitting/#curve-fitting-tutorial","text":"Note Curve fitting is the simple process of finding a surrogate function approximating a system dynamics, ie curve fitting. For example in epidemiology, cumulative deaths grow slowly at first, accelerate when the epidemics is at the peak and slows down to reach a plateau, this can be approximated using a logistic function. # Base Data Science snippet import pandas as pd import numpy as np import matplotlib.pyplot as plt import os import time from tqdm import tqdm_notebook % matplotlib inline % load_ext autoreload % autoreload 2 # Developer import import sys sys . path . append ( \"../\" ) The autoreload extension is already loaded. To reload it, use: %reload_ext autoreload import pyepidemics","title":"Curve fitting tutorial"},{"location":"tutorials/curve_fitting/#introduction","text":"","title":"Introduction"},{"location":"tutorials/curve_fitting/#introduction-to-curve-fitting","text":"Epidemic curves often follow a particular shape : Cumulative deaths reach a plateau, we could approximate it with a logistic curve Infections, stay in hospital, often reach a peak before declining, we could approximate it with a gaussian or skewed gaussian curve This is what curve fitting is about, once we have a surrogate function approximating the epidemic curve we can make predictions. Yet it only works under the assumption that the situation is constant which is totally unrealistic. However even if the model is wrong, that does not mean is not useful, curve fitting can easily be used at scale on many countries or used to capture the dynamics of epidemics curve to better calibrate compartmental models","title":"Introduction to curve fitting"},{"location":"tutorials/curve_fitting/#getting-some-data","text":"from pyepidemics.dataset import fetch_daily_case_france cases = fetch_daily_case_france () cases [[ \"D\" , \"H\" , \"ICU\" ]] . plot ( figsize = ( 15 , 4 ), title = \"COVID19 cases (D=Dead,H=Hospital,ICU)\" ) plt . show ()","title":"Getting some data"},{"location":"tutorials/curve_fitting/#curve-fitting-in-practice","text":"from pyepidemics.curve_fitting import logistic_fn , gaussian_fn from pyepidemics.curve_fitting import CurveFittingModel","title":"Curve fitting in practice"},{"location":"tutorials/curve_fitting/#surrogate-functions","text":"","title":"Surrogate functions"},{"location":"tutorials/curve_fitting/#logistic-function","text":"A logistic function is useful to represent system dynamics reaching a plateau after an inflexion. More on the wikipedia page https://en.wikipedia.org/wiki/Logistic_function Formula is : f(x)=\\frac{a}{1+e^{-k(x - \\mu)}} f(x)=\\frac{a}{1+e^{-k(x - \\mu)}} We can use the fonction pyepidemics.curve_fitting.logistic_fn(x,a,mu,k) # Take x between 0 and 100 x = np . linspace ( 0 , 100 ) # Prepare plot plt . figure ( figsize = ( 15 , 4 )) # Plot many functions for k in [ 0.05 , 0.1 , 0.2 , 0.5 , 1 ]: plt . plot ( logistic_fn ( x , k = k , a = 10 , mu = 50 ), label = f \"k={k}\" ) # Display figure plt . title ( \"Logistic functions\" ) plt . legend () plt . show ()","title":"Logistic function"},{"location":"tutorials/curve_fitting/#gaussian-function","text":"Formula is : f(x)=a e^{-0.5(\\frac{x-\\mu}{\\sigma})^2} f(x)=a e^{-0.5(\\frac{x-\\mu}{\\sigma})^2} We can use the fonction pyepidemics.curve_fitting.gaussian_fn(x,a,mu,sigma) # Take x between 0 and 100 x = np . linspace ( 0 , 100 ) # Prepare plot plt . figure ( figsize = ( 15 , 4 )) # Plot many functions for sigma in [ 5 , 10 , 20 ]: plt . plot ( gaussian_fn ( x , sigma = sigma , a = 10 , mu = 50 ), label = f \"sigma={sigma}\" ) # Display figure plt . title ( \"Gaussian functions\" ) plt . legend () plt . show ()","title":"Gaussian function"},{"location":"tutorials/curve_fitting/#fitting-surrogate-functions-to-covid-cases","text":"We will use the CurveFittingModel which merely wraps curve_fit function from scipy in a scikit learn fashion. from pyepidemics.curve_fitting import CurveFittingModel","title":"Fitting surrogate functions to COVID cases"},{"location":"tutorials/curve_fitting/#fitting-the-death-cases","text":"Let's start by fitting the death cases with a logistic function model = CurveFittingModel ( \"logistic\" ) Fitting returns the parameters a,mu,k of the logistics function model . fit ( cases [ \"D\" ]) array([1.75350267e+04, 7.87308460e+01, 1.16910544e-01]) Let's predict for 20 days after the date and visualize the fit pred = model . predict ( 20 , show_fit = True )","title":"Fitting the death cases"},{"location":"tutorials/curve_fitting/#fitting-the-icu-cases-with-gaussian-curve","text":"model = CurveFittingModel ( \"gaussian\" ) pred = model . fit_predict ( cases [ \"ICU\" ], show_fit = True ) It works ok, but actually ICU cases are not a proper gaussian curve, we have a step ascend in the number of cases, and a slower decline. Hence what we need here could simply be a skewed guassian model = CurveFittingModel ( \"skewed_gaussian\" ) pred = model . fit_predict ( cases [ \"ICU\" ], show_fit = True ) Now we have a much better fit","title":"Fitting the ICU cases with gaussian curve"},{"location":"tutorials/curve_fitting/#advanced-users","text":"There are a few details you can use as an advanced user, deep dive into the code internals to learn more : You can specify the initial parameters p0 of the curve fitting optimization freely by passing p0 argument to the fit or fit_predict function. Actually for the gaussian functions those initial parameters are automatically inferred from the dataset provided to facilitate convergence. You can actually specify any function to fit in the curve fitting model as shown below","title":"Advanced users"},{"location":"tutorials/curve_fitting/#fitting-a-custom-function","text":"Let's create a fake dataset with a simple linear function # Preparing the true function and the function with noise example_fn = lambda x , a , b : a * x + b example_fn_random = lambda x , a , b : example_fn ( x , a , b ) + np . random . randn ( len ( x )) * 2 # Parameter we want to estimate a = 2 b = 1 # Creating fake dataset x = np . linspace ( 0 , 20 ) y = example_fn_random ( x , a , b ) # Visualizing fake dataset plt . figure ( figsize = ( 15 , 4 )) plt . scatter ( x , y ) plt . show () And here we are, we have a Linear Regression model model = CurveFittingModel ( example_fn ) pred = model . fit_predict ( y ) # Visualizing fake dataset plt . figure ( figsize = ( 15 , 4 )) plt . scatter ( x , y ) plt . plot ( x , pred ) plt . show ()","title":"Fitting a custom function"}]}